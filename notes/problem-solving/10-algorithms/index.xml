<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>10-Classic Algorithm on Zangwei</title>
    <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/</link>
    <description>Recent content in 10-Classic Algorithm on Zangwei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>zhengzangw at gmail.com (Zangwei Zheng)</managingEditor>
    <webMaster>zhengzangw at gmail.com (Zangwei Zheng)</webMaster>
    <lastBuildDate>Wed, 16 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengzangw.com/notes/problem-solving/10-algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>String Algorithm</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-string/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-string/</guid>
      <description>&lt;h1 id=&#34;字符串匹配&#34;&gt;字符串匹配&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;$w\sqsubset x$：w 为 x 前缀&lt;/li&gt;
&lt;li&gt;$w\sqsupset x$: w 为 x 后缀&lt;/li&gt;
&lt;li&gt;后缀重叠引理：$x\sqsupset z,y\sqsupset z,|x|\leq|y|\Rightarrow x\sqsupset y$&lt;/li&gt;
&lt;li&gt;$P_k=P[1..k]$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;朴素方法&#34;&gt;朴素方法&lt;/h2&gt;
&lt;p&gt;$O((n-m+1)m)$&lt;/p&gt;
&lt;h2 id=&#34;rabin-karp-算法&#34;&gt;Rabin-Karp 算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;预处理 $O(m)$
&lt;ul&gt;
&lt;li&gt;编码，利用对素数取模，减少计算量&lt;/li&gt;
&lt;li&gt;相等则逐字编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最坏情况 $O((n-m+1)m)$&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>KM algorithm</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-km/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-km/</guid>
      <description>&lt;h1 id=&#34;km-算法&#34;&gt;KM 算法&lt;/h1&gt;
&lt;h2 id=&#34;概念推导&#34;&gt;概念推导&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可行顶标：每个节点有一个顶标值 $L(u)$，二分图两边的顶标分别记为 $Lx(u),Ly(v)$&lt;/li&gt;
&lt;li&gt;可行顶标性质：$lx(x)+ly(y)\geq w(x,y)$&lt;/li&gt;
&lt;li&gt;可行边：边 $w(x,y)$ 满足 $lx(x)+ly(y)=w(x,y)$&lt;/li&gt;
&lt;li&gt;相等子图：原图中只包含可行边的生成子图&lt;/li&gt;
&lt;li&gt;完备匹配：匹配中每个顶点与某条边相关&lt;/li&gt;
&lt;li&gt;最大权重匹配定理：若某个相等子图中有完备匹配，则该匹配为原图最佳匹配&lt;/li&gt;
&lt;li&gt;松弛函数：二分图一边的节点保存 $slack(x)=\min(lx(i)+ly(j)-w(i,j))$&lt;/li&gt;
&lt;li&gt;顶标修改：减少不在交错路中最小的松弛值&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>贪心专题</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-greedy/</link>
      <pubDate>Mon, 17 Sep 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-greedy/</guid>
      <description>&lt;h1 id=&#34;活动选择问题&#34;&gt;活动选择问题&lt;/h1&gt;
&lt;p&gt;最早结束&lt;/p&gt;
&lt;h1 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h1&gt;
&lt;p&gt;最小合并&lt;/p&gt;
&lt;h2 id=&#34;合并花费最小问题&#34;&gt;合并花费最小问题&lt;/h2&gt;
&lt;h1 id=&#34;字符串拼接字典序最小&#34;&gt;字符串拼接字典序最小&lt;/h1&gt;
&lt;p&gt;比较a+b与b+a&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linear Recurrence</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-linear-recurrence/</link>
      <pubDate>Sun, 26 Aug 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-linear-recurrence/</guid>
      <description>&lt;h1 id=&#34;常系数齐次线性递推式&#34;&gt;常系数齐次线性递推式&lt;/h1&gt;
&lt;p&gt;快速幂: $O(k^3logn)$
黑科技：$O(klogklogn+k)$
虽然过了洛谷的数据，但是常数还没压下来，N=10^9,K=32000要3.5s。标程可以进1s。以后再压常数。&lt;/p&gt;
&lt;h2 id=&#34;幻想三步走&#34;&gt;幻想三步走&lt;/h2&gt;
&lt;p&gt;设转移矩阵为A，初始值向量为v&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Segment Tree</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/segment-tree/</link>
      <pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/segment-tree/</guid>
      <description>&lt;h1 id=&#34;prepare&#34;&gt;Prepare&lt;/h1&gt;
&lt;h2 id=&#34;离散化&#34;&gt;离散化&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a.y
sort(m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unique(m,m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; m
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) a[i].y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lower_bound(m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;len&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,a[i].y) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; m;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>FFT</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-fft/</link>
      <pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-fft/</guid>
      <description>&lt;h2 id=&#34;fft&#34;&gt;FFT&lt;/h2&gt;
&lt;p&gt;迭代实现，计算卷积。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>背包九讲</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-knapsack/</link>
      <pubDate>Thu, 10 May 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-knapsack/</guid>
      <description>dp 九讲
01 背包 $$F[i,v] = \max{F[i-1,v],F[i-1,v-Ci]+Wi}$$
for i=1 to N for v = V to Ci F[v] = max{F[v],F[v-Ci]+Wi} 恰好装满：$F[1..V] = -\infty; F[0] = 0$
无必要： $F[0..V] = 0$
完全背包 $$F[i,v] = \max{F[i-1,v-kCi] + kWi | 0&amp;lt;=kCi&amp;lt;=v &amp;amp;&amp;amp; 0&amp;lt;=k&amp;lt;Mi}$$ （利用$F[i,v-Ci]$代换）
 $O(n^2)$ 若两件物品 i、j 满足 Ci≤Cj 且 Wi≥Wj，则将可以将物品 j 直接去掉，不用考虑 $O(V+N)$ 首先将费用大于 V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个 把第 i 种物品拆成费用为 Ci2k、价值为 Wi2k 的若干件物品，其中 k 取遍满足 Ci2k≤V 的非负整数  for i = 1 to N for v = Ci to v F[v] = max(F[v],F[v-Ci]+Wi) 多重背包 完全背包思路（可以看作是分组背包问题）</description>
    </item>
    
    <item>
      <title>Skip list</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/skip-list/</link>
      <pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/skip-list/</guid>
      <description>&lt;h1 id=&#34;skip-list&#34;&gt;Skip List&lt;/h1&gt;
&lt;h2 id=&#34;构造&#34;&gt;构造&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;给定一个有序的链表。&lt;/li&gt;
&lt;li&gt;选择连表中最大和最小的元素，然后从其他元素中按照一定算法（随机）随即选出一些元素，将这些元素组成有序链表。&lt;/li&gt;
&lt;li&gt;为刚选出的每个元素添加指针指向下一层中值同自己相等的元素。Top指针指向该层首元素&lt;/li&gt;
&lt;li&gt;重复2、3步，直到不再能选择出除最大最小元素以外的元素。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>DP优化——四边形不等式</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-optimization/</link>
      <pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-optimization/</guid>
      <description>&lt;h2 id=&#34;四边形不等式条件&#34;&gt;四边形不等式条件&lt;/h2&gt;
&lt;p&gt;任意 $a1\leq a2&amp;lt;b1\leq b2$,有 $F(a_1,b_1)+F(a_2,b_2)\leq F(a_1,b_2)+F(a_2,b_1)$
则函数 F 满足四边形不等式&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>区间动归</title>
      <link>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-interval/</link>
      <pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/10-algorithms/algorithm-dp-interval/</guid>
      <description>&lt;h1 id=&#34;interval-dp&#34;&gt;Interval DP&lt;/h1&gt;
&lt;h2 id=&#34;区间动归特征&#34;&gt;区间动归特征&lt;/h2&gt;
&lt;p&gt;利用序作为状态&lt;/p&gt;
&lt;h2 id=&#34;题目一览&#34;&gt;题目一览&lt;/h2&gt;
&lt;p&gt;石子合并、能量项链、数字游戏、乘积最大、加分二叉树、关路灯、选择数字、Acting Cute、GF弹钢琴、水果姐逛水果街Ⅰ&lt;/p&gt;
&lt;h2 id=&#34;石子合并&#34;&gt;石子合并&lt;/h2&gt;
&lt;h3 id=&#34;question&#34;&gt;Question:&lt;/h3&gt;
&lt;p&gt;在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。
试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
