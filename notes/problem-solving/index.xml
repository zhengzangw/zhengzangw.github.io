<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[A] 问题求解 Problem Solving on Zangwei</title>
    <link>https://zhengzangw.com/notes/problem-solving/</link>
    <description>Recent content in [A] 问题求解 Problem Solving on Zangwei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>zhengzangw at gmail.com (Zangwei Zheng)</managingEditor>
    <webMaster>zhengzangw at gmail.com (Zangwei Zheng)</webMaster>
    <lastBuildDate>Wed, 16 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengzangw.com/notes/problem-solving/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-算法复杂度分析与正确性证明</title>
      <link>https://zhengzangw.com/notes/problem-solving/1-algorithm-analysis/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/1-algorithm-analysis/</guid>
      <description>正确性证明 Loop invariants Initialization Maintenance Termination 时间复杂度 cost: 硬件执行一条指令的代价 times: 指令被执行的次数 running time 计算方法: $T(n)=\sum c_i n_i$ worst-case running time average-case running time （按输入求期望） expected running time （任意输入，按程序随机数求期望） rate(order) of growth $\Theta(g(n)) = {f(n):\exists c_1,c_2,n_0,\forall n\geq n_0,0\leq c_1g(n)\leq f(n)\leq c_2g(n)}$ $O(g(n)) = {f(n):\exists c,n_0,\forall n\geq n_0, f(n)\leq cg(n)}$ $\Omega(g(n)) = {f(n):\exists c,n_0,\forall n\geq n_0, 0\leq cg(n)\leq f(n)}$ $o(g(n)) = {f(n):\exists c,n_0,\forall n\geq n_0, 0\leq f(n)&amp;lt; cg(n)}$ $\omega(g(n)) = {f(n):\exists c,n_0,\forall n\geq n_0, 0&amp;lt;cg(n)\leq f(n)}$ $\lg(n!</description>
    </item>
    
    <item>
      <title>2-排序与数字统计</title>
      <link>https://zhengzangw.com/notes/problem-solving/2-sorting-and-order/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/2-sorting-and-order/</guid>
      <description>排序 插入排序 for (int j=2; j&amp;lt;A.size(); ++j){ auto key = A[j]; for (int i = j-1; i&amp;gt;0 &amp;amp;&amp;amp; A[i]&amp;gt;key; --i) A[i + 1] = A[i]; A[i + 1] = key; } 循环不变量：每次循环开始前，子数组 A[1..j-1] 有序 worst: $\Theta(n^2)$ average: $\Theta(n^2)$ 归并排序 void merge_sort(vector&amp;lt;int&amp;gt;&amp;amp; A, int l, int r){ if (l &amp;lt; r){ int mid = (l+r)/2; merge_sort(vector&amp;lt;int&amp;gt;&amp;amp; A, l, mid); merge_sort(vector&amp;lt;int&amp;gt;&amp;amp; A, mid, r); merge(A, l, mid, r); // O(r-l) } } worst case: $\Theta(n\lg n)$ average case: $\Theta(n\lg n)$ 堆排序 build_max_heap(A) for i in range(A.</description>
    </item>
    
    <item>
      <title>3-数据结构</title>
      <link>https://zhengzangw.com/notes/problem-solving/3-data-structure/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/3-data-structure/</guid>
      <description>Dynamic sets operations Search(S, k) Insert(S, x) Delete(S, x) Min/Max(S) Successor(S, x) Precessor(S, x) data structure augmentation choose an underlying data structure determine addtional information to maintain verify it can be maintained develop new operations 优先队列 operation Insert(S, x) Max(S) extract_max(S) increase_key(S, x, k) not good for Search 线性数据结构 Stack Queue Linked list 堆 property max-heap property: A[Parent(i)]$\geq$A[i] procedure max-heapify $O(\lg n)$ build-max-heap $O(n)$ max-heap-insert/extract/increase $O(\lg n)$ def max_heapify(A, i): # l, r are already max-heaps l = 2 * i r = 2 * i + 1 if l &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>4-算法设计</title>
      <link>https://zhengzangw.com/notes/problem-solving/4-algorithm-design/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/4-algorithm-design/</guid>
      <description>brute-force 枚举：遍历解空间 倍增：保存 $2^i$ 处的解用于构造所有情况 递归：原问题划归到一个子问题 搜索：建立树/图模型，以一定次序穷举 模拟 剪枝：利用数学性质缩小解空间 前缀和、差分 打表：将不同问题的解储存 Divide and Conquer 分治法 def Divide_and_Conquer(A): if (smallenough) return Conquer() Divide_and_Conquer(A_left) Divide_and_Conquer(A_right) Merge(A_left, A_right) Examples:
归并排序： $T(n)=2T(n/2)+\Theta(n)$ 快速排序： 和最大子数组： $T(n)=2T(n/2)+\Theta(n)$ 矩阵乘法：$T(n)=8T(n/2)+\Theta(n^2)$ strassen&amp;rsquo;s algorithm: $T(n)=7T(n/2)+\Theta(n^2)$ 二分法 无 merge 的分治法 问题已有序关系 // 左闭右闭 int i_left = 0, i_right = len; while (i_left &amp;lt;= i_right){ int i = (i_left + i_right)/2; if (isleft(i_left, i)) // do something else if (isright(i, i_right)) // do somethin else // do something } 动态规划 子问题图：顶点为子问题，边为可能选择 实现方法 top-down with memorization（记忆化搜索） bottom-up method 动态规划过程 Define structure of subproblem Set the goal Identify the recurrence -&amp;gt; make choice(binary/multi-way) from small to large init condition Write pseudo-code Analyze the time complexity Extract the optimal solution optimal substructure: 问题的最优解由子问题的最优解组合而成，而这些子问题可以独立求解 make a decision 子问题无关 cut-and-paste: 任意其它子问题的方案可被最优方案替代 overlapping subproblem: 问题的递归算法会反复地求解相同的子问题 Examples:</description>
    </item>
    
    <item>
      <title>5-图论</title>
      <link>https://zhengzangw.com/notes/problem-solving/5-graph-theory/</link>
      <pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/5-graph-theory/</guid>
      <description>Introduction Graph $G=(V,E)$ order $|V|$ incident $u\sim v$: u and v are neighbors walk $W = (u=v_0, v_1, \dots, v_k = v)$ open walk: $u\neq v$ closed walk: $u=v$ trail: $u$-$v$ walk in which no edge is traversed more than once circuit: a closed trial of length 3 or more path: $u$-$v$ walk in which no vertices are repeated cycle: a circuit that repeats no vertex, except for the first and last connected: $\exists$ $u$-$v$ path distance $d(u,v)$: exists smallest $u$-$v$ path $P=(u=v_0,\dots,v_k=v)$ geodesic $u$-$v$ of length $d(u,v)$ diamemter $\text{diam}(G)=\max_{u,v}(d(u,v))$ subgraph proper $G&amp;rsquo;=(V&amp;rsquo;,E&amp;rsquo;),V&amp;rsquo;\subsetneq V$ or $E&amp;rsquo;\subsetneq E$ spanning $G&amp;rsquo;=(V,E&amp;rsquo;),E&amp;rsquo;\subseteq E$ induced $G&amp;rsquo;=(V&amp;rsquo;,E&amp;rsquo;)$: $\forall u,v\in V&amp;rsquo;,$ if $uv\in E$, then $uv\in E&#39;$ edge-induced component: 最大连通子图 Common Graphs trivial graph: $|V|=1$ $P_n$ : path (graph) $C_n$: circle (graph) $K_n$ : complete graph bipartite graph: contains no odd cycle $K_{s,t}$: complete bipartite graph $K_{1,t}$ or $K_{s,1}$: star k-partite graph $K_{i_1,\dots,i_k}$: complete k-partite graph n-cubes (hypercubes): $Q_n = Q_{n-1} \times K_2$, $Q_1 = K_2$ Operation Complement: $\overline{G}=(V,K_n-E)$ Union: $G_1 \cup G_2=(V_1\cup V_2,E_1\cup E_2)$ Join: $G+H=(V_1\cup V_2, E_1\cup E_2\cup (V_1\times V_2))$ Cartesian product $G\times H=(V(G)\times V(H),E&amp;rsquo;),((u,v),(x,y))\in E&amp;rsquo;$ if $u=x,vy\in E(H)$ or $v=y,ux\in E$ multigraph: $E$ is a multiset parallel edges: join the same pair of vertices pseudograph: $(u,u)\in E$ oriented graph: if $(u,v)\in E$, $(v,u)\notin E$ oritentation of G Storage adjacent matrix edge set（可以链式前向星实现） Digraph digraph (directed graph): $(v,u)\neq (u,v)$ $(u,v)$: $u$ adjacent to $v$, $v$ adjacent from $u$ symmetric: $(u,v)\in E\iff(v,u)\in E$ underlying graph: replace direction and parallel edges tournament: orientation of complete graph transitive: $(u,v),(v,w)\in T,(u,w)\in T$ every tournament contains a Hamiltonian path Hamiltonian iff strong weakly connected: underlying graph is connected strongly connected: $\forall u,v,\exists P$ from $u$ to $v$ and vice versa strongly connected component (SCC) Semiconnected Digraph: $u\sim v$ or $v\sim u$ Toposort + edges $(v_i,v_{i+1})$ exsits Isomorphism isomorphic $G\cong H$: $\exists$ 1-1 $\phi:V(G)\rightarrow V(H)$ such that $uv\in E(G)\Rightarrow\phi(u)\phi(v)\in E(H)$ self-complementary: $G \cong \overline G$ isomorphism is an equivalence relation of the set of all graphs automorphism: isomorphism from $G$ to $G$ $\text{Aut}(H)$: automorphism group of $G$ (under composition) $u$ and $v$ are similar: they are in same orbit vertex-transitive: $G$ contains a single orbit Frucht&amp;rsquo;s Theorem: For every finite group $A$, there exists a graph $G$ such that $\text{Aut}(G)$ is isomorphic to $A$ recognizable: a parameter of $G$ can be determined from $G-v,v\in V(G)$ $|V|$ $|E|$ for $|V|\geq3$ degree sequence for $|V|\geq 3$ reconstructible: $G$ can be uniquely determined (up to isomorphism) from subgraphs $G-v_i$ Reconstruction Conjecture: $G$ is reconstructible for $|V|\geq 3$ Trees bridge $e$: $G$ is connected, $G-{e}$ is disconnected bridge $\iff$ $!</description>
    </item>
    
    <item>
      <title>6-难问题求解</title>
      <link>https://zhengzangw.com/notes/problem-solving/6-hard-problems/</link>
      <pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/6-hard-problems/</guid>
      <description>Definition Alphabet $\Sigma$: alphabet $\Sigma^*=\mathcal{P}(\Sigma)$ $\Sigma^+=\Sigma^*-{\lambda}$ $s\in\Sigma$: symbol $s\in w$ $w\subseteq\Sigma, \omega\in\Sigma^*$: word over $\Sigma$ $w\in L$ $\lambda$: empty word $|w|$: length of word $\Sigma^n={w\in\Sigma^*|\vert w\vert=n}$ #$_a(w)$: number of occurence of $a$ in $w$ $vw$: concatenation of $v$ and $w$ $w^{n+1}=ww^n,w^0=\lambda$ prefix, suffix, subword $L\subseteq\Sigma^*$: language over $\Sigma$ $L^C =\Sigma^*-L$ $L_1L_2={uv\in(\Sigma_1\cup\Sigma_2)^*|u\in L_1,v\in L_2}$: concatenation canonical ordering: let $s_1&amp;lt;&amp;hellip;&amp;lt;s_m$ be a linear ordering, $u&amp;lt;v$ if $\vert u\vert&amp;lt;\vert v\vert$ or $\vert u\vert=\vert v\vert,u=xs_iu&amp;rsquo;,v=xs_jv&amp;rsquo;,i&amp;lt;j$ Algorithmic Problems polynomially related: codings $e_1\in L_1,e_2\in L_2,\exists f:L_1\rightarrow L_2,f(e_1)$ is polynomial decision Problem: $(L,U,\Sigma),L\subseteq U\subseteq \Sigma^*$ $A$ solves/decides $U$ $A(x)=1,x\in L$ $A(x)=0,x\in U-L$ $A$ accepts $U$: $A(x)=1,x\in L$ Halting Problem: Undecidable but acceptable optimization Problem: $U=(\Sigma_I,\Sigma_O,L,L_I,M,cost,goal)$ briefly: $U=(L,$ constraints, costs, goal$)$ $\Sigma_I$: input alphabet $\Sigma_O$: output alphabet $L\subset\Sigma_I^*$: language of feasible Problem instances $L_I\subset L$: language of the actual Problem instance $M:L\rightarrow \mathcal{P}(\Sigma_O^*)$, $\mathcal{M}(x)$ is the set of feasible solutions for $x$ cost$:\mathcal{M}(x)\times L\rightarrow \mathbb{R}$ goal $\in{\min,\max}$ optimal solution $Opt_U(x)=cost(y,x)=goal_{x\in L_I}{cost(z,x)|z\in \mathcal{M}(x)}$ $Output_U(x)\subseteq \mathcal{M}(x)$: all optimal solutions for instance $x\in U$ Algorithm $A$ is consistent for $U$: $\forall x\in L_I,A(x)\in \mathcal{M}(x)$ Algorithm $B$ solves $U$ consistent $\forall x\in L_I,B(x)=Opt_U(x)$ $U_1$ is a subProblem of $U_2$ if $L_{I,1}\subseteq L_{I,2}$ (Others are same) Turing Machine Turing Machine: $M=(Q,\Sigma,\Gamma,\delta,q_0,q_{ac},q_{rej})$ $Q$: state set $\Sigma$: Input alphabet $\Gamma\subseteq\Sigma$: alphabet on tape $\delta:Q\times\Gamma\rightarrow Q\times\Gamma\times{L,R,-}$ $q_0\in Q$: initial satate nondeterministic TM: $\delta:Q\times\Gamma\rightarrow \mathcal{P}(Q\times\Gamma\times{L,R})$ nondeterministic TM $M$ accept $L=L(M)$ $\forall x\in L,\exists$ computation of $M$ accepts $x$ $\forall y\not\in L$, all computations of $M$ rejects $y$ time complexity of nondeterministic TM $M$ $T_M(\omega)$: shortest accepting computation of $M$ on $\omega$ $T_M(n)=\max{T_M(x)|x\in L(M)\cap\Sigma^n}$ Church-Turing thesis: Problem $U$ can be solved by an algorithm iff $\exists$ Turing machine solving $U$ Theorem: for every increasing function $f:\mathbb{N}\rightarrow\mathbb{R}^+$ $\exists$ decision Problem such that every TM solving it has the time complexity in $\Omega(f(n))$ but $\exists$ TM solving it in $O(f(n)\log f(n))$ $L(M)$: language decided by $M$ Examples Decision PRIM: test if a number is a prime EQ-POL: $p_1\equiv p_2$ in $\mathbb{Z}_p$ EQ-1BP: equivalence of one-time-only branching programs C-SAT: whether a formula with AND, NOT, OR gate is satisfiable SAT (kSAT): whether a CNF can be satisfied Clique: whether a graph contain $K_k$ VCP: whether graph contains a vertex cover of size $k$ HC: whether graph contains a Hamiltonian cycle SOL-IP: existence of a solution of linear integer programming SOL-0/1-IP SOL-IP$_p$ PM: whether a bipartite graph has a perfect matching SUBSET-SUM: exists a subset $S&amp;rsquo;\subseteq S$ sum up to $t$ Optimization TSP: find a Hamiltonian cycle of the minial cost in a complete weighted graph $\Delta$-TSP: metric traveling salespaerson Problem (satisfying triangle inequality) Euclidean TSP: geometrical, can be embedded in the two-dimensional Euclidean space MSP: Makespan Scheduling Problem MIN-VCP: find minimum vertex cover WEIGHT-VCP SCP: Set Cover Problem MAX-CL: Maximum Clique Problem MAX/MIN-CUT KP: Knapsack Problem SKP: Simple Knapsack Problem BIN-P: Bin-Packing Problem MAX-SAT: maximize the number of stisfied clauses MAX-kSAT MAX-EkSAT: exactly LP: Linear Programming IP: Integer Linear Programming 0/1-Linear Programming MAX-LinModk: Maximum Linear Equation Problem Mod k MAX-EmLinModk: k is prime, m is positive integer MAX-CSP: $\max_{S,T}|E(S,T)|$ Complexity Theory main objective of the complexity theory is: find a formal specification of the class of practically solvable Problems to develop methodes enabling the classification of algorithmic Problemcs accoording to their membershiop in this class uniform cost all numbers bounded basic operation: $O(1)$ logarithmic cost numbers $k$ takes $O(\lg k)$ bits addition, subtraction, assignment: $O(n)$ multiplication, division: $O(n\log n)$ pseudopolynomial time complexity: $T(n)$ is polynomial in the numeric value of the input $T(n)$ is not polynomial in the number of bits required to repensent it of the input bound $T/S_A(x)$: time/space complexity on $x\in\Sigma_I$ $T/S_A(n)=\max{T/S_A(x)|x\in\Sigma_I^n}$: worst case analysis upper bound on the time complexity of $U$: $\exists A$ solving $U$ with $T_A(n)\in O(g(n))$ lower bound on the time complexity of $U$: $\forall B$ solving $U$ has $T_B(n)\in\Omega(f(n))$ There is a decision Problem such that $\forall A$ deciding $L$, $\exists B$ deciding $L$: $T_A(n)=\log_2T_B(n)$ optimal algorithm: $\text{Time}_C(n)\in O(g(n))$ and $\Omega(g(n))$ is a lower bound Complexity Class Complexity Zoo $\text{P}={L(M)|M$ is a TM, $\exists c&amp;gt;0,T_M(n)\in O(n^c)}$ tractable (solvable): $L\in P$, $L$ is accepted/decided by a polynomial-time algorithm intractable: $L\not\in P$ $\text{NP}={L(M)|M$ is a polynomial-time nondeterministic TM$}$ verifier for $L$: $A$ works on $\Sigma^\times{0,1}^$, $L=V(A)={\omega\in\Sigma^|\exists c\in{0,1}^,A$ accepts $(\omega,c)}$ $\text{NP}={V(A)|T_A(\omega,c)\in O(|\omega|^d)}$ closed under $\cap,\cup,\cdot,\star$ polynomial-time reduction (Karp, many-one) $L_1\leq_p L_2$: $\exists$ poly.</description>
    </item>
    
    <item>
      <title>7-Number Theory</title>
      <link>https://zhengzangw.com/notes/problem-solving/7-number-theory/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/7-number-theory/</guid>
      <description>背景知识 自然数的集合论定义： $a^+:=a\cup{a}$ 归纳集 $\emptyset\in A$ $\forall a(a\in A\rightarrow a^+\in A)$ $\mathbb{N}$ 为所有归纳集之交 Peano 结构 $e\in S$ $\forall a\in S,f(a)\in S$ $\forall b\in S,\forall c\in S,f(b)=f(c)\rightarrow b=c$ $\forall a\in S,f(a)\not= e$ $\forall A\subseteq S, (e\in A\wedge(\forall a\in A)(f(a)\in A))\rightarrow A=S$ 良序公理与数学归纳法原理等价 数论基础 带余除法: $a=bq+r,b&amp;gt;0,0\leq r&amp;lt;b$ 存在性证明：良序公理 唯一性证明 整除及其性质 $a|b,a|c\Rightarrow a|nb+mc$ 最大公因子 (hcf/gcd) 裴蜀定理：$\gcd(a,b)=ar+bs$ 证明：良序公理+带余除法 Strong Duality for GCD: $\max{d_i:d\in\mathbb{Z},d|a,d|b}=\min{ax+by:x\in\mathbb{Z},y\in\mathbb{Z},ax+by&amp;gt;0}$ 证明 $d|s,s|d$ Weak Duality + $\exists$ 唯一性证明 $\text{lcm}(a,b)\gcd(a,b)=ab$ 证明 Isomorphism Theorem Unique Factorization $d|(a,b)\Leftrightarrow d|\frac{ab}{[a,b]}$ $(a,b,c)[a,b,c]=\frac{abc}{[(a,b),(b,c),(c,a)]}$ $[a,b,c]=\frac{abc(a,b,c)}{(a,b)(a,c)(b,c)}$ $\gcd(a,b,c)=\gcd(\gcd(a,b),c)$ 质数 $\pi(x)\sim\frac{x}{\ln{x}}$ 无限质数证明 $P=p_1p_2\cdots p_n+1$ Fermat Numer $F_n=2^{2^n}+1$ 两两互素 $F_n-2=\prod_{k=1}^{n-1}F_k$ Mersenne Number $2^p-1$ $2^p\equiv 1\pmod{q}\Rightarrow p|q-1$ Dirichlet&amp;rsquo;s Theorem: $\gcd(a,m)=1$ then there are infinitely many primes $p,p\equiv a\pmod{m}$ 筛法求素数 算术基本定理 存在性证明：良序公理（找不满足中最小的） 唯一性证明：$1\rightarrow n$ $\varphi(n)=n\prod_{p|n}(1-\frac{1}{p}),p$ is prime $\varphi(p)=p-1$ $\varphi(n)&amp;gt;\frac{n}{e^\gamma\ln\ln n+\frac{3}{\ln\ln n}},\gamma=0.</description>
    </item>
    
    <item>
      <title>8-Cryptography</title>
      <link>https://zhengzangw.com/notes/problem-solving/8-cryptography-and-coding/</link>
      <pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/problem-solving/8-cryptography-and-coding/</guid>
      <description>概论 密码系统：$(\mathcal{K}, \mathcal{M}, \mathcal{C})$ $\mathcal{K}$ 所有可能秘钥组成的集合 $\mathcal{M}$ 所有可能明文组成的集合 $\mathcal{C}$ 所有可能密文组成的集合 密码：$(E,D)$ $E$: 加密算法 $\mathcal{M}\times\mathcal{K}\rightarrow\mathcal{C}$ $D$: 解密算法 $\mathcal{D}\times\mathcal{K}\rightarrow\mathcal{M}$ 一致性原则：$\forall m\in M,k\in K,D(k,E(k,m))=m$ 通常 $E$ 是一个随机化算法 $D$ 一定是一个确定化算法 OTP (One Time Pad) $K={0,1}^n$ $M={0,1}^n$ $C={0,1}^n=\mathcal{M}$ $E(m,k)=k\oplus m$ $D(c,k)=k\oplus c$ PRG 伪随机数生成器 高效，确定，不可预测 流密码 A stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). In a stream cipher, each plaintext digit is encrypted one at a time with the corresponding digit of the keystream, to give a digit of the ciphertext stream.</description>
    </item>
    
  </channel>
</rss>
