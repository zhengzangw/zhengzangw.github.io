<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>[&#43;] 软件工程 Software Engineering on Zangwei</title>
    <link>https://zhengzangw.com/notes/software-enginerring/</link>
    <description>Recent content in [&#43;] 软件工程 Software Engineering on Zangwei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>zhengzangw at gmail.com (Zangwei Zheng)</managingEditor>
    <webMaster>zhengzangw at gmail.com (Zangwei Zheng)</webMaster>
    <lastBuildDate>Wed, 27 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengzangw.com/notes/software-enginerring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-软件工程引论</title>
      <link>https://zhengzangw.com/notes/software-enginerring/1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%BC%95%E8%AE%BA/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%BC%95%E8%AE%BA/</guid>
      <description>软件问题历史  1996年6月4日因软件失效在发射40秒后爆炸，原因是惯性参考系统软件的数据转换异常造成的失效。 2004年12月20日，美空军第422测试评估大队的一架F-22战斗机因软件问题在起飞过程中失控坠毁。 2003年8月14日，美国北部电力丢失，原因是多计算机系统试图同时访问同一资源引起的软件失效 2004年9月14日，5 p.m. 美国400架飞机失去联络，原因是空管软件时钟缺陷 2005年11月1日，东京证券交易所因为软件升级出现系统故障，导致早间股市“停摆” 2002年NIST估计软件问题造成美国年经济损失约600亿美元，占GDP的0.6% 2007年5月17日和18日，诺顿杀毒软件导致全部安装了该软件的计算机系统瘫痪  软件危机  表现：成本高，软件质量得不到保证，进度难以控制，维护非常困难 根本原因  逻辑产品 复杂性高 规模大 缺乏有效、系统的原理、原则、方法和工具的指导与辅助   软件工程：为克服软件危机而提出的一种概念  核心内容：按工程化的原则和方法组织软件开发工作 主要任务：通过提供规范化的分析设计方法及工具软件，来避免或减少软件错误的发生，为最终根除软件危机提供强有利的技术保障   软件产品没有“质保”，没有“三包” 复杂系统的五个共同属性（Grady Booch）  Hierarchic Structure Relative Primitives Separation of Concerns Common Patterns Stable Intermediate Forms    软件工程内容 软件需求 ,软件设计 ,软件建模 ,软件体系结构 ,设计模式 ,软件构造 ,软件测试 ,软件维护 ,软件配置管理 ,软件工程管理 ,软件过程 ,软件工程工具与方法 ,软件质量
软件工程目标 可修改性，有效性，可靠性，可理解性，可维护性，可重用性，可适应性，可移植性，可追踪性，可互相操作性
软件工程原则  抽象，信息隐藏，模块化，局部化，一致性，完整性，可验证性 Davis 提出的软件工程原则  质量放在首位 高质量的软件是可能的 尽早向客户提供产品 在编写需求之前确定问题 评估可选设计方案 使用适当的过程模型 在不同阶段使用不同的语言 最小化智力差距 将技术置于工具之前 在使之更快之前，请确保其正确性 检查代码 好的管理比好的技术更重要 人是成功的关键 勿盲目跟风 承担责任   Walker Royce的现代软件管理十大原则  基于架构优先的方法建立过程。 建立一个迭代过程，以通过此过程尽早解决风险。 强调基于组件的开发，以减少编码工作量。 应该建立变更管理来处理迭代过程。 增强迭代开发过程环境（称为双向工程），以通过自动化工具在多个制品上频繁地进行多次变更。 使用基于模型和计算机可处理的符号来进行设计。 建立质量控制和项目进度评估的客观过程，包括评估所有中间制品。 为能够更早地评估中间制品，使用基于演示的方法，将其转换为用户场景的可执行演示。 计划增量式发布多个版本，每个版本由一组使用场景组成，并在细节上逐步演化。 建立一个可配置的过程，因为没有一个过程适合所有的软件开发。    中间件  在操作系统层之上的计算抽象层，提升编程抽象层次 屏蔽了底层异构环境 三大中间件平台：CORBA, J2EE, .</description>
    </item>
    
    <item>
      <title>2-软件过程模型</title>
      <link>https://zhengzangw.com/notes/software-enginerring/2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>经典软件工程方法 问题定义 -&amp;gt; 需求 -&amp;gt; 分析 -&amp;gt; 设计 -&amp;gt; 编码 -&amp;gt; 测试 -&amp;gt; 维护
software process  the way we produce software, 以人为主体  evolution model waterfall model Iterative-and-incremental Process Models    waterfall model evolution-tree life-cycle model at the end of each episode we have a baseline: a complete set of artifacts
artifact: a constituent component of a software product
Iterative-and-incremental Process Models  Incrementation(增量): 指对于产品的功能上、模块上的增加 Iteration(迭代): 指增量部分仍然使用相同的流程来开发  generic process framework  framework activities  Communication Planning Modeling Construction Deployment   umbrella activities：普适性活动，是所有框架性活动都会涉及到的  project tracking and control risk management quality assurance configuration management technical reviews    software life-cycle model  a description of the steps that should be performed when building a software product，从软件自身来看 core workflows in life-cycles  Requirements workflow Analysis workflow Design workflow Implementation workflow Test workflow    Code-and-Fix life-cycle model waterfall life-cycle model or classic life cycle</description>
    </item>
    
    <item>
      <title>3-软件需求与分析</title>
      <link>https://zhengzangw.com/notes/software-enginerring/3-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/3-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</guid>
      <description>软件需求  软件需求：用户解决问题或达到目标所需的条件或权能，或系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能的文档说明 需求层次  邻域需求（业务需求）：应用邻域的要求 用户需求：表达高层的概要的需求 系统需求：描述系统应该提供的服务及其约束   秋千图  需求工程 (RE)  目标：创建和维护系统的需求文档 需求开发  可行性研究：经济、技术、法律 需求获取/定义：访谈、会议、参观、实践  客户权利 客户义务   需求分析：从用户处获得需求、形成与用户需求相一致的、可供阅读的软件需求规格说明书的过程  结构化方法 面向对象模型 原型方法   需求调查   需求管理技术与工具  需求确认 需求验证（需求评审） 需求变更控制   文档  需求文档  BRD（Business Requirement Document）商业需求文档：内容主要涉及市场分析，销售策略，盈利预测等，通常面向的对象是公司负责人、投资人和股东 MRD: 这是立项后开发前产出的文档，目的是指出产品的市场定位和特色功能。通常面向的对象是公司领导，商务、运营、市场人员等 PRD（Product Requirement Document）产品需求文档   需求分析报告：面向用户  内容：功能与行为需求、非功能需求、设计约束（如硬件、软件、网络等环境）、开发周期等 IEEE/ANSI 830-1998 GB/T 8586-2008   需求规格说明书 SRS：面向设计开发人员    需求规格文档（基于原型的）  小红书 PRD PMP 产品需求文档作用  传达产品开发需求 保证各部门沟通有理有据 产品质量控制有具体标准   工具  Word + Axure Axure8 + 标注   原型图避免涉及到颜色，只需要黑、白、灰、红 内容  产品简介（+商业需求文档） 版本说明 开发周期 历史版本 修订历史 思维导图：产品结构图、信息结构图、流程图等 全局说明：展示整个产品的设计规范 交互原型 用例文档   需求量化 需求复用  </description>
    </item>
    
    <item>
      <title>4-软件设计-SA</title>
      <link>https://zhengzangw.com/notes/software-enginerring/4-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-sa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/4-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-sa/</guid>
      <description>结构化分析方法 SA  分析：从问题域向求解域迈进的第一步 分析活动的产生制品是应用域专家和计算机专家都可以看得懂的规格说明 基本思想：: “自顶向下，逐步求精” ,“抽象和分解” 结构化方法=结构化分析+结构化设计+结构化程序设计 分解：把系统的复杂性降低到可以掌握的程度，把大问题分解成若干小问题，然后分别解决 抽象：即先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容 分析结果  数据字典：定义数据，描述了所有的在目标系统中使用的和生成的数据对象 数据流程图：表达信息系统中数据的流向方式（功能建模）  功能 = 功能 + {子功能} + 功能接口 数据流法 = 数据流 + 数据处理 + 数据存储 + 端点 + 处理说明 + 数据字典   实体&amp;mdash;关系图 ERD：描述数据对象及数据对象之间的关系（数据建模） 状态&amp;mdash;迁移图 STD：描述系统对外部事件如何响应，如何动作（行为建模） 系统关系图：系统与外界相关系统的输入与输出  系统 = 实体 + 属性 + 关系   信息结构图：表达系统的顶层架构、体现分解的过程 加工规格说明：定义数据的处理    结构化设计方法  结构化程序设计（Dijkstra）：概要设计+详细设计  概要设计 概念  模块化：软件被划分成独立命名和可独立访问的被称作模块的构件，每个模块完成一个子功能，它们集成到一起满足问题需求 实现模块化的手段  抽象：抽出事物的本质特性而暂时不考虑它们的细节 信息隐蔽：应该这样设计和确定模块，使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不可访问的   模块独立性：开发具有独立功能而且和其它模块之间没有过多的相互作用的模块 独立性衡量  耦合性：开发具有独立功能而且和其它模块之间没有过多的相互作用的模块 内聚性：标志一个模块内各个处理元素彼此结合的紧密程度，理想的内聚模块只做一件事情   耦合分类  无任何连接（最低耦合） 数据耦合（低耦合）：两个模块彼此通过参数交换信息，且交换的仅仅是数据 控制耦合（中耦合）：两个模块之间传递的信息有控制成分 公共环境耦合：两个或多个模块通过一个公共环境相互作用  一个存一个取：低耦合 都存取数据：低&amp;mdash;中耦合   内容耦合  一个模块访问另一个模块的内部数据 两个模块有一部分程序代码重叠 一个模块不通过正常入口而转移的另一个的内部 一个模块有多个入口     内聚分类  偶然内聚（低）：一组任务关系松散 逻辑内聚（低）：一组任务在逻辑上同属一类，例如均为输出 时间内聚（低）：一组任务必须在同一段时间内执行 信息内聚（中）：模块内所有元素都引用相同的输入或输出数据集合 顺序内聚（高）：模块中的每个元素都是与同一功能紧密相关，一个元素的输出是下一个元素的输入 功能内聚（高）：一个模块完成一个且仅完成一个功能   扇出数：由一模块直接控制的其他模块的数目 扇入数：有多少个模块直接控制一个给定的模块  设计方法  面向数据流的设计  信息流  变换流：信息沿输入通路进入系统，同时由外部形式变换成内部形式。进入系统的信息通过变换中心，经过加工处理以后再沿着输出通路变换成外部形式离开系统。 事务流：事务流的特点是数据沿着接收通路把外部世界的信息转换成一个事务项，然后，计算该事务项的值，根据它的值激励起多条活动通路中的一条数据流。发出多条通路的信息流中枢被称为“事务中心”     面向数据结构的设计：Jackson 方法  详细设计  详细设计是给出软件结构中各模块的内部过程描述 图形工具  流程图 方块图（N-S） PAD 图   语言工具：PDL(Program Design Language) 软件设计说明书  系统的目标和作为系统元素的软件的作用 硬件、软件与人机接口 主要的软件功能 外部定义的数据库 主要的设计约束与限制 设计说明：数据说明、导出的软件结构、结构内接口 模块说明  处理说明 接口说明 设计语言说明 使用模块 数据组织 注解   文件结构和全程数据    </description>
    </item>
    
    <item>
      <title>5-软件设计-OOAD</title>
      <link>https://zhengzangw.com/notes/software-enginerring/5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-ooad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-ooad/</guid>
      <description>UML  UML 历史  UML 建立在当今国际上最有代表性的三种面向对象方法（Booch 方法，OMT 方法，OOSE 方法）的基础之上 UML 由 OMG 于 1997 年 11 月正式采纳为标准   UML 为人们提供了从不同的角度去观察和展示系统的各种特征的一种标准表达方式 UML 视角  使用实例：外部操作者 逻辑结构：从内部描述如何设计实现系统功能 构成 并发性 配置   UML 语义  元-元模型：元模型的基础体系结构，定义一种说明元模型的语言 元模型：元-元模型的一个实例，定义一种说明模型的语言 模型：元模型的一个实例，定义一种语言来描述信息领域 用户对象：模型的一个实例，定义一个特定的领域   UML 2.0 目标：服务于模型驱动软件开发  Superstructure：定义了用户级的构造块（constructs ），用于对系统的结构、行为进行详述（如，类图、顺序图等） Diagram Interchange：定义了针对 UML 的图交换标准，用于对模型以及模型图（包含图形的布局信息）进行交换 Infrastructure：定义了最基本的构造块，用于描述 UML 本身以及针对特定的域（如，实时领域）对 UML 进行定制 OCL：用于定义针对模型以及模型元素的约束信息   UML 工具  IBM Rational Rose Borland Together Eclipse: Papyrus, Topcased    功能  用例图  Use Case：用户与计算机之间为达到某个目的的一次典型交互作用 执行者 联系    结构   类图：描述了系统中的类及其相互之间的各种关系</description>
    </item>
    
    <item>
      <title>6-设计模式</title>
      <link>https://zhengzangw.com/notes/software-enginerring/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式简介  起源与建筑学：《A Pattern Language: Towns, Buildings, Construction》建筑的永恒之道，Christopher Alexander 模式：A Pattern Language: Towns, Buildings, Construction  Context：模式可适用的前提条件 Theme/Problem：在特定条件下要解决的目标问题 Solution：对目标问题求解过程中各种物理关系的记述   软件设计模式：《Design Patterns》Gang of Four 软件模式：软件开发的总体指导思路或参照样板  在软件生存期的每一个阶段都存在着一些被认同的模式 对软件开发这一特定“问题”的“解法”的某种统一表示 软件模式等于一定条件下的出现的问题以及解法 Pattern name, Problem, Solution, Consequences   大三律(Rule of Three)：只有经过三个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式 设计模式分类  目的  Creational: 创建对象 Structural: 处理类或对象的组合 Behavioral: 描述对类或对象怎样交互和怎样分配职责   范围  类模式：处理类和子类之间的关系，静态 对象模式：处理对象间的关系，动态      设计原则  开放封闭原则（Open Close Principle）：类、模块、函数等应该是可以拓展的，但是不可修改 里氏替换原则（Liskov Substitution Principle）：所有引用基类的地方必须能透明地使用其子类的对象。  如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型 类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法   依赖倒置原则（Dependence Inversion Principle）：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 单一职责原则(Single Responsibility Principle)：就一个类而言， 应该仅有一个引起它变化的原因。  防止职责扩散   接口隔离原则（InterfaceSegregation Principles）：一个类对另一个类的依赖应该建立在最小的接口上。 迪米特原则（Law of Demeter）也称最少知识原则：一个软件实体应当尽可能少地与其他实体发生相互作用。  降低耦合，减少扇入扇出   合成复用原则  GoF 设计模式  单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。  </description>
    </item>
    
    <item>
      <title>7-软件测试和验证</title>
      <link>https://zhengzangw.com/notes/software-enginerring/7-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E9%AA%8C%E8%AF%81/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/7-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E9%AA%8C%E8%AF%81/</guid>
      <description>软件缺陷  Error: 人的错误行为导致软件中出现不希望或不可接受的内部状态 Fault: 软件运行时出现不希望或不可接受的状态 Failure: 软件运行时产生了不希望或不可接受的外部行为结果 incident: 软件运行中出现了与失效类似的现象 anomaly: 软件运行中出现了未预期的现象 Vulnerability: 能被利用进行攻击的代码缺陷 variance: 软件中于要求不一致处 Defect (Bug): 存在于软件生存期中哪些不希望或不可接受的偏差  错误 遗漏 额外实现   因需求产生的缺陷最多 在软件生存期中，缺陷发现和清除的越晚，需付出的代价越大 技术手段  需求/设计  自然语言：评审 半形式语言（UML）：评审+验证 形式语言：自动验证   代码  评审 分析：程序分析 验证：模型检验、推理证明   可执行系统  测试：白盒、黑河、灰盒 运行时验证 监控/容错      程序分析  静态分析与动态分析 工具：Coverity, PCLint, Clang, Klocwork  软件测试  测试活动：标识 - 设计 - 开发 - 执行 - 比较   功能测试与非功能测试  黑盒方法  将测试对象看做黑色盒子，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明 穷尽测试：黑盒测试中穷尽所有可能输入条件和输出条件（不可能）  等价类划分法  将程序输入域划分为若干部分，每个子集中选取少数具有代表性的数据作为测试用例 有效等价类：检验程序是否实现了规格说明中预先规定的功能和性能 无效等价类：无意义的、不合理的输入数据所构成的集合 标准等价类测试：不考虑无效数据值，测试用例使用每个等价类中的一个值 健壮等价类测试：对无效输入，一个测试用例有一个无效值，其他值均取有效值  需要花费精力定义无效测试用例的期望输出 对强类型的语言没有必要考虑无效的输入   测试用例设计   构建等价类表</description>
    </item>
    
    <item>
      <title>8-软件维护和演化</title>
      <link>https://zhengzangw.com/notes/software-enginerring/8-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%BC%94%E5%8C%96/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/8-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E5%92%8C%E6%BC%94%E5%8C%96/</guid>
      <description>软件支持  产品缺陷性支持与非缺陷性支持 支持成本  商用软件：服务收费 开源软件：Stackoverflow, github   外层：客服  咨询电话 在线提交问题   技术问题  交付及安装补丁集    软件维护  软件维护原则  不损害程序的质量 保持程序风格的一致性和功能的完整性 应有利于将来程序的改变 对用户没有不利的影响   基于缺陷的软件维护  缺陷定位/调试：程序频谱 缺陷修复：自动修复技术 回归测试 集成    软件演化  变更控制  发起变更请求 批准变更请求 执行变更请求 跟踪和关闭变更请求   程序理解 二次开发 集成  Devops   DevOps: 版本研发 + 交付上线
 版本研发：持续交付 流程：敏捷开发    开发过程
 集成 Integration：编译、测试、打包 部署 Deployment：应用组件或基本设施的代码或配置变更在产品环境生效称为“部署” 发布 Release：具有业务影响的功能变化对最终用户可见 交付 Delivery：从 Deployment 到 Release 之间的阶段，更多的强调的是一种能力    三个阶段</description>
    </item>
    
    <item>
      <title>9-实际开发流程案例</title>
      <link>https://zhengzangw.com/notes/software-enginerring/9-%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>zhengzangw at gmail.com (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/notes/software-enginerring/9-%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%A1%88%E4%BE%8B/</guid>
      <description>开发流程人员安排  产品总监：确定产品方向（问题定义）  BRD MRD 竞品分析文档 产品体验报告 评审：会议纪要   产品经理：可行性研究+需求获取  产品原型 PRD 需求分析报告 需求规格说明书   UI 设计师：界面设计、需求设计、研发设计  界面效果图、UI设计规范   研发工程师：概要设计、详细设计、软件设计说明书 研发项目经理：项目研发周报 测试工程师：项目测试周报，测试结果报告，系统使用说明书 系统上线  </description>
    </item>
    
  </channel>
</rss>
