<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Solution to OJ - Range Sum of Multiset | Zangwei</title>

    
    <link rel="stylesheet" href="/scss/main.min.6c4d523b15a1f1714ec1a02eecf7283de3733cb142ca8bf9edd01f9f077cc730.css" integity="sha256-bE1SOxWh8XFOwaAu7PcoPeNzPLFCyov57dAfnwd8xzA=">

    <script type="text/javascript" src="/js/dark.js"></script>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
</head><body class="app auto flex-container">
    <div class="flex-container flex-column"><nav>
    <hr>
    <div class="flex-container flex-row flex-row-full">
        
        <div class="nav-item">
            <a href="/about">[ About ]</a>
        </div>
        
        <div class="nav-item">
            <a href="/pdfs/resume.pdf">[ CV ]</a>
        </div>
        
        <div class="nav-item">
            <a href="/#Publications">[ Publication ]</a>
        </div>
        
        <div class="nav-item">
            <a href="/#Teaching-Assistant">[ Teaching ]</a>
        </div>
        
        <div class="nav-item">
            <a href="/notes">[ Notes ]</a>
        </div>
        
        <div class="nav-item">
            <a href="/friends">[ Friends ]</a>
        </div>
        
        <div class="nav-item btn btn-switch">
            <a>[ <span class="theme-name">Auto</span> ]</a>
        </div>
    </div>
    <hr>
</nav>
<div class="flex-passage flex-row flex-row-full">
            <div class="flex-column-20">
                <div class="return">
                    <a href=".."> RETURN </a>
                </div>
                <nav id="TableOfContents">
  <ul>
    <li><a href="#range-sum-of-multiset">Range Sum of Multiset</a></li>
    <li><a href="#示例代码-treap--跳表">示例代码 (Treap &amp; 跳表)</a></li>
  </ul>
</nav>
            </div>
            <main class="flex-column-80"><p>题目连接：<a href="https://oj.chaodong.me/problem/multisetdup">Range Sum of Multiset</a></p>
<h2 id="range-sum-of-multiset">Range Sum of Multiset</h2>
<p>本题要求实现一个支持在线插入(1)、删除(2)、区间和(3)的数据结构。根据数据规模 $1\leq Q\leq 5\cdot 10^5$，我们需要 $O(\lg n)$ 的时间支持这三种操作。</p>
<p>如果只需要支持操作 1,2，我们可以采用平衡树（红黑树，Treap）或者跳表。为了支持操作 3，我们需要在原数据结构上额外维护一下区间相关的内容。为了求 $[l,r]$ 区间内的和，我们可以维护每个结点的前缀和，用前缀和来计算区间和。</p>
<p>可以参考网上 <a href="https://oi-wiki.org/ds/treap/">Treap</a> 和 <a href="https://oi-wiki.org/ds/skiplist/">跳表</a> 的实现。</p>
<p>对于 Treap，要注意的是前缀和并不是子树之和，而是左子树之和。</p>
<p>对于跳表，可以在每层的每个结点维护：在该层，该节点到前一结点之间的元素之和。实现的时候要注意指针的使用。</p>
<h2 id="示例代码-treap--跳表">示例代码 (Treap &amp; 跳表)</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">#define MAXN 500000
</span><span style="color:#75715e"></span><span style="color:#75715e">// #define DEBUG
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/* Treap */</span>

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#66d9ef">int64_t</span> key, sum_left, sum_right;
    <span style="color:#66d9ef">int</span> pri, w, l, r;
} treap_node;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">treap_rotate</span> {
    treap_node node[MAXN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">int</span> rt, sz;
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">l_rotate</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> node[k].r;
        node[k].r <span style="color:#f92672">=</span> node[t].l;
        node[t].l <span style="color:#f92672">=</span> k;
        <span style="color:#75715e">// update sum
</span><span style="color:#75715e"></span>        node[k].sum_right <span style="color:#f92672">=</span> node[t].sum_left <span style="color:#f92672">-</span> node[t].w <span style="color:#f92672">*</span> node[t].key <span style="color:#f92672">+</span>
                            node[k].w <span style="color:#f92672">*</span> node[k].key;
        node[t].sum_left <span style="color:#f92672">+=</span> node[k].sum_left;

        <span style="color:#75715e">// update pointer
</span><span style="color:#75715e"></span>        k <span style="color:#f92672">=</span> t;
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">r_rotate</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k) {
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> node[k].l;
        node[k].l <span style="color:#f92672">=</span> node[t].r;
        node[t].r <span style="color:#f92672">=</span> k;
        <span style="color:#75715e">// update sum
</span><span style="color:#75715e"></span>        node[k].sum_left <span style="color:#f92672">=</span> node[t].sum_right <span style="color:#f92672">-</span> node[t].w <span style="color:#f92672">*</span> node[t].key <span style="color:#f92672">+</span>
                           node[k].w <span style="color:#f92672">*</span> node[k].key;
        node[t].sum_right <span style="color:#f92672">+=</span> node[k].sum_right;
        <span style="color:#75715e">// update pointer
</span><span style="color:#75715e"></span>        k <span style="color:#f92672">=</span> t;
    }
    <span style="color:#75715e">// Insert
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_insert</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">int64_t</span> x) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>k) {
            k <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>sz;
            node[sz].key <span style="color:#f92672">=</span> node[sz].sum_left <span style="color:#f92672">=</span> node[sz].sum_right <span style="color:#f92672">=</span> x;
            node[sz].pri <span style="color:#f92672">=</span> rand();
            node[sz].w <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            node[sz].l <span style="color:#f92672">=</span> node[sz].r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">==</span> x) {
                node[k].sum_left <span style="color:#f92672">+=</span> x;
                node[k].sum_right <span style="color:#f92672">+=</span> x;
                node[k].w<span style="color:#f92672">++</span>;
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">&lt;</span> x) {
                node[k].sum_right <span style="color:#f92672">+=</span> x;
                _insert(node[k].r, x);
                <span style="color:#66d9ef">if</span> (node[node[k].r].pri <span style="color:#f92672">&lt;</span> node[k].pri) l_rotate(k);
            } <span style="color:#66d9ef">else</span> {
                node[k].sum_left <span style="color:#f92672">+=</span> x;
                _insert(node[k].l, x);
                <span style="color:#66d9ef">if</span> (node[node[k].l].pri <span style="color:#f92672">&lt;</span> node[k].pri) r_rotate(k);
            }
        }
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int64_t</span> x) { _insert(rt, x); }
    <span style="color:#75715e">// Remove
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_find</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">int64_t</span> x) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>k) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> node[k].key)
            <span style="color:#66d9ef">return</span> _find(node[k].l, x);
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> _find(node[k].r, x);
    }
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_remove</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">int64_t</span> x) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>k) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">==</span> x) {
            <span style="color:#66d9ef">if</span> (node[k].w <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
                node[k].w<span style="color:#f92672">--</span>;
                node[k].sum_left <span style="color:#f92672">-=</span> x;
                node[k].sum_right <span style="color:#f92672">-=</span> x;
                <span style="color:#66d9ef">return</span> node[k].w <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">if</span> (node[k].l <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> node[k].r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                    k <span style="color:#f92672">=</span> node[k].l <span style="color:#f92672">+</span> node[k].r;
                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node[node[k].l].pri <span style="color:#f92672">&lt;</span> node[node[k].r].pri) {
                    r_rotate(k);
                    <span style="color:#66d9ef">return</span> _remove(k, x);
                } <span style="color:#66d9ef">else</span> {
                    l_rotate(k);
                    <span style="color:#66d9ef">return</span> _remove(k, x);
                }
            }
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">&lt;</span> x) {
            node[k].sum_right <span style="color:#f92672">-=</span> x;
            <span style="color:#66d9ef">return</span> _remove(node[k].r, x);
        } <span style="color:#66d9ef">else</span> {
            node[k].sum_left <span style="color:#f92672">-=</span> x;
            <span style="color:#66d9ef">return</span> _remove(node[k].l, x);
        }
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int64_t</span> x) {
        <span style="color:#66d9ef">if</span> (_find(rt, x))
            <span style="color:#66d9ef">return</span> _remove(rt, x);
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#75715e">// Query
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int64_t</span> <span style="color:#a6e22e">_querysum</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>k, <span style="color:#66d9ef">int64_t</span> x) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>k) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span> (node[k].key <span style="color:#f92672">&lt;=</span> x) {
            <span style="color:#66d9ef">return</span> node[k].sum_left <span style="color:#f92672">+</span> _querysum(node[k].r, x);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> _querysum(node[k].l, x);
        }
    }
    <span style="color:#66d9ef">int64_t</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int64_t</span> l, <span style="color:#66d9ef">int64_t</span> r) {
        <span style="color:#66d9ef">return</span> _querysum(rt, r) <span style="color:#f92672">-</span> _querysum(rt, l);
    }
};

<span style="color:#75715e">/* Skip List */</span>

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> max_level <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SkipNode</span> {
    <span style="color:#66d9ef">int64_t</span> key;
    <span style="color:#66d9ef">int</span> w, level;
    SkipNode <span style="color:#f92672">**</span>nxt;
    <span style="color:#66d9ef">int64_t</span> <span style="color:#f92672">*</span>sum_pre;
    SkipNode(<span style="color:#66d9ef">int64_t</span> k, <span style="color:#66d9ef">int</span> level) <span style="color:#f92672">:</span> key(k), level(level) {
        nxt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SkipNode <span style="color:#f92672">*</span>[level];
        sum_pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int64_t</span>[level];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> level; <span style="color:#f92672">++</span>i) {
            nxt[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
            sum_pre[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        }
        w <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
} skip_node;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">skip_list</span> {
   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    skip_node <span style="color:#f92672">*</span>head, <span style="color:#f92672">*</span>tail;
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">random_level</span>() {
        <span style="color:#66d9ef">int</span> random_level <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> seed <span style="color:#f92672">=</span> time(NULL);
        <span style="color:#66d9ef">static</span> default_random_engine e(seed);
        <span style="color:#66d9ef">static</span> uniform_int_distribution<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> u(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);

        <span style="color:#75715e">// while (rand() % 2 &amp;&amp; random_level &lt; max_level) random_level++;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (u(e) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> random_level <span style="color:#f92672">&lt;</span> max_level) random_level<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">return</span> random_level;
    };
    skip_node <span style="color:#f92672">*</span><span style="color:#a6e22e">_find_pre</span>(<span style="color:#66d9ef">int64_t</span> x) {
        skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
            <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> x)
                tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
        }
        <span style="color:#66d9ef">return</span> tmp;
    }
    <span style="color:#66d9ef">int64_t</span> <span style="color:#a6e22e">_sum</span>(<span style="color:#66d9ef">int64_t</span> x) {
        skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
        <span style="color:#66d9ef">int64_t</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
            <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;=</span> x) {
                tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                sum <span style="color:#f92672">+=</span> tmp<span style="color:#f92672">-&gt;</span>sum_pre[i];
            }
        }
        <span style="color:#66d9ef">return</span> sum;
    }

   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    skip_list() {
        head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> skip_node(LLONG_MIN, max_level);
        tail <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> skip_node(LLONG_MAX, max_level);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> max_level; <span style="color:#f92672">++</span>i) {
            head<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">=</span> tail;
        }
    };
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int64_t</span> x) {
        skip_node <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> _find_pre(x)<span style="color:#f92672">-&gt;</span>nxt[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">==</span> x) {
            node<span style="color:#f92672">-&gt;</span>w<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>level; <span style="color:#f92672">++</span>i) node<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">+=</span> x;
            skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> node<span style="color:#f92672">-&gt;</span>level; <span style="color:#f92672">--</span>i) {
                <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> x)
                    tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">+=</span> x;
            }
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">int</span> r_level <span style="color:#f92672">=</span> random_level();
            skip_node <span style="color:#f92672">*</span>new_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> skip_node(x, r_level);
            skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
                <span style="color:#66d9ef">int64_t</span> acc_sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> x) {
                    tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                    acc_sum <span style="color:#f92672">+=</span> tmp<span style="color:#f92672">-&gt;</span>sum_pre[i];
                }
                <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> r_level) {
                    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> r_level) new_node<span style="color:#f92672">-&gt;</span>sum_pre[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> acc_sum;
                    new_node<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                    tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">=</span> new_node;
                } <span style="color:#66d9ef">else</span> {
                    tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">+=</span> x;
                }
            }
            new_node<span style="color:#f92672">-&gt;</span>sum_pre[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> x;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> new_node<span style="color:#f92672">-&gt;</span>level; <span style="color:#f92672">++</span>i) {
                new_node<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">+=</span> new_node<span style="color:#f92672">-&gt;</span>sum_pre[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
                new_node<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-=</span> new_node<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-</span> x;
            }
        }
    }
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int64_t</span> x) {
        skip_node <span style="color:#f92672">*</span>node <span style="color:#f92672">=</span> _find_pre(x)<span style="color:#f92672">-&gt;</span>nxt[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">!=</span> x) {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>w <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
                node<span style="color:#f92672">-&gt;</span>w<span style="color:#f92672">--</span>;
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>level; <span style="color:#f92672">++</span>i) node<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-=</span> x;
                skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> node<span style="color:#f92672">-&gt;</span>level; <span style="color:#f92672">--</span>i) {
                    <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> x)
                        tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                    tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-=</span> x;
                }
                <span style="color:#66d9ef">return</span> node<span style="color:#f92672">-&gt;</span>w <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                skip_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> head;
                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> max_level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
                    <span style="color:#66d9ef">while</span> (tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">&amp;&amp;</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;</span> x)
                        tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i];
                    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>level) {
                        tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">+=</span>
                            tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-</span> x;
                        tmp<span style="color:#f92672">-&gt;</span>nxt[i] <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>nxt[i];
                    } <span style="color:#66d9ef">else</span> {
                        tmp<span style="color:#f92672">-&gt;</span>nxt[i]<span style="color:#f92672">-&gt;</span>sum_pre[i] <span style="color:#f92672">-=</span> x;
                    }
                }
                <span style="color:#66d9ef">delete</span> node;
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
            }
        }
    }
    <span style="color:#66d9ef">int64_t</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int64_t</span> l, <span style="color:#66d9ef">int64_t</span> r) { <span style="color:#66d9ef">return</span> _sum(r) <span style="color:#f92672">-</span> _sum(l); }
};

<span style="color:#75715e">/*
</span><span style="color:#75715e">Use Treap
</span><span style="color:#75715e">    Time: 9s, Memory: 22.1 MB
</span><span style="color:#75715e">*/</span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">treap_rotate</span> Multiset;

<span style="color:#75715e">/*
</span><span style="color:#75715e">Use Skip List
</span><span style="color:#75715e">    max_level = 10, TLE
</span><span style="color:#75715e">    max_level = 15, Time: 13.4s, Memory: 59.0 MB
</span><span style="color:#75715e">    max_level = 20, Time: 13.8s, Memory: 59.0 MB
</span><span style="color:#75715e">    max_level = 40, Time: 14.8s, Memory: 59.0 MB
</span><span style="color:#75715e">*/</span>
<span style="color:#75715e">// typedef struct skip_list Multiset;
</span><span style="color:#75715e"></span>
Multiset S;
<span style="color:#66d9ef">int64_t</span> Q, mod, lans, y, x, l, r, u, v, cnt;
<span style="color:#66d9ef">int</span> q;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74">&#34;%lld%lld&#34;</span>, <span style="color:#f92672">&amp;</span>Q, <span style="color:#f92672">&amp;</span>mod);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; t <span style="color:#f92672">&lt;</span> Q; <span style="color:#f92672">++</span>t) {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>q);
        <span style="color:#66d9ef">switch</span> (q) {
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
                scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>, <span style="color:#f92672">&amp;</span>y);
<span style="color:#75715e">#ifndef DEBUG
</span><span style="color:#75715e"></span>                x <span style="color:#f92672">=</span> (y <span style="color:#f92672">+</span> lans) <span style="color:#f92672">%</span> mod;
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>                x <span style="color:#f92672">=</span> y;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>                S.insert(x);
                <span style="color:#75715e">// printf(&#34;0 %lld\n&#34;, x);
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
                scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>, <span style="color:#f92672">&amp;</span>y);
<span style="color:#75715e">#ifndef DEBUG
</span><span style="color:#75715e"></span>                x <span style="color:#f92672">=</span> (y <span style="color:#f92672">+</span> lans) <span style="color:#f92672">%</span> mod;
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>                x <span style="color:#f92672">=</span> y;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>                cnt <span style="color:#f92672">=</span> S.remove(x);
                printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt);
                <span style="color:#75715e">// printf(&#34;1 %lld\n&#34;, x);
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
                scanf(<span style="color:#e6db74">&#34;%lld%lld&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);
<span style="color:#75715e">#ifndef DEBUG
</span><span style="color:#75715e"></span>                l <span style="color:#f92672">=</span> (u <span style="color:#f92672">+</span> lans) <span style="color:#f92672">%</span> mod;
                r <span style="color:#f92672">=</span> (v <span style="color:#f92672">+</span> lans) <span style="color:#f92672">%</span> mod;
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>                l <span style="color:#f92672">=</span> u;
                r <span style="color:#f92672">=</span> v;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&gt;</span> r) swap(l, r);
                lans <span style="color:#f92672">=</span> S.query(l, r);
                printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lans);
                <span style="color:#75715e">// printf(&#34;2 %lld %lld\n&#34;, l, r);
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div></main>
        </div>

    </div>
</body></html>