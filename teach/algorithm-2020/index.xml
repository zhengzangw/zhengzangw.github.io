<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TA: Algorithm Analysis and Design (NJU, CS, Fall 2020) on Zangwei</title>
    <link>https://zhengzangw.com/teach/algorithm-2020/</link>
    <description>Recent content in TA: Algorithm Analysis and Design (NJU, CS, Fall 2020) on Zangwei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>zzw at smail.nju.edu.cn (Zangwei Zheng)</managingEditor>
    <webMaster>zzw at smail.nju.edu.cn (Zangwei Zheng)</webMaster>
    <lastBuildDate>Mon, 26 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://zhengzangw.com/teach/algorithm-2020/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Solution to HW 5</title>
      <link>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-5/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      <author>zzw at smail.nju.edu.cn (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-5/</guid>
      <description>10-19 6.1 空间上消耗可能增多，时间上摊还复杂度低（$1+\frac{4}{3}t$）。两种方法视实际情况需要使用。
6.2 应该使用均摊分析（有些同学写了平均分析，实际给的是一种特殊情况下的时间开销）
根据书中的 accounting scheme，在无 shrink 的情况下，push 的 amortized cost 为 $1+2t$，pop 的 amortized cost 为 $1$。这道题的处理关键在于要考虑 pop 操作的 credit
  (a) 取临界情况（栈大小 $n$，$n-1$ 次 push 后反复 push + pop）可知均摊时间复杂度非常数（均摊分析也是在最坏情况下的分析）
  (b) push: $1+2t$, pop: $1+t$
考虑已扩展到 $4N$ 的情况
 $2N\sim 4N$: push 的 accounting 足够 $N\sim2N$: push 的 accounting 保证下一次 push 时 credit 为正，pop 累积有 $Nt$ 的 accounting 用于 shrink    (c) push: $1+2t$, pop: $1$</description>
    </item>
    
    <item>
      <title>Solution to HW 4</title>
      <link>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-4/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      <author>zzw at smail.nju.edu.cn (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-4/</guid>
      <description>10-12 6.11 Tips: 分情况讨论
  ansRight.status = ok/rbr
  ansRight.status = brb
 oldTree.color = black oldTree.color = red    otherwise
 oldTree.leftSubtree.color = red oldTree.leftSubtree.color = black    6.15 略
6.16  (1) 右旋+左旋 (2) 左旋 (3) r = black, 左旋 (4) s = black, p = red, 左旋  6.17  (a) 错误 (b) 错误  10-15 6.18 略
6.19 言之有理即可。(a) 简单的可以认为空间多两倍</description>
    </item>
    
    <item>
      <title>Solution to HW 3</title>
      <link>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-3/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      <author>zzw at smail.nju.edu.cn (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-3/</guid>
      <description>注意这次交三次的作业，缺交的同学及时补交（邮箱：zzw@smail.nju.edu.cn）
9-24 4.2
  (a) $\frac{1}{2}n(n-1)$, decreasing sequence
  (b) increasing, $n-1$
4.3
  (a) 用循环不变式证明 （$E[j]$ is the maximum in $[0,j]$)
  (b) 略
4.4
  (a) 可利用 4.3(a) 的循环不变式证明
  略
  不影响
4.23
  注意需使用 Section 2.3.2 的数据结构
4.27
  (a) 可以使用两个数组 $A,B$，基于归并时处于归并树结点深度的奇偶性，奇数时保存到 $A$，偶数时保存到 $B$（滚动数组）
  (b) $n\log n$
4.28
  找中点：设置两个指针，一个步长为 1， 一个步长为 2，当快指针到达尾结点时，慢指针指向中间结点。该时间复杂度为 $O(n)$。由于 merge 也是 $O(n)$，时间复杂度不变为 $O(n\log n)$。空间复杂度 $O(n\log n)$，有 garbage collection 为 $O(n)$</description>
    </item>
    
    <item>
      <title>Solution to HW 2</title>
      <link>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-2/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      <author>zzw at smail.nju.edu.cn (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-2/</guid>
      <description>共 13 题。不会的题不要空着，展示一些思路，都有分的。
可以不抄题目，但请装订后上交。做的好的我用星（下次用 A）打了标记，很差的用 B 打标记（暂时没有）
4.7
最好情况：已经排序，比较 n-1 次
4.8
 (a) $n-1+\log_2[(n-1)!]=\Theta(n\log n)$ (b) $\frac{(n-1)n}{2}$ (d) 链表可以减少移动次数，但无法进行二分查找（不能直接索引）  4.9
平均复杂度变低（相同 key 取同一个）/ 渐进平均复杂度不变
4.11
时间复杂度 $\Theta(n^2)$，无垃圾回收空间复杂度 $\Theta(n^2)$，有垃圾回收 $\Theta(n)$
4.14
   before i left-end right-end vacancy     2 low high left   3 low high left   4 low highVac right   5 lowVac highVac left    4.15</description>
    </item>
    
    <item>
      <title>Solution to HW 1</title>
      <link>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-1/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      <author>zzw at smail.nju.edu.cn (Zangwei Zheng)</author>
      <guid>https://zhengzangw.com/teach/algorithm-2020/solution-to-algorithm-1/</guid>
      <description>作业评分：每题 10 分，选做属于加分题
一些共性的问题：
 作业只收到 41 份，名单有 54 位同学，请确认自己已经提交作业 作业严禁抄袭 作业记得写好学号姓名，并用订书钉或回形针等方式装订好 许多同学表示不会写伪代码  作业都只需要给出伪代码，理论上不应该使用任何一种实际的编程语言书写（如 java/c/python）很多同学作业中伪代码直接交了可运行的代码，这样书写很费时间，同时也没法很好展示自己的思路 写伪代码主要在于展现算法思路，只需要保留核心算法部分即可。一些辅助函数在说明了功能后可以直接使用，没必要完整的写出来。这里放一篇 pseudo code 的参考文章 大家可以看一下教程上给的代码示例，如 4.8 Heapsort 这一章的伪代码    海盗分金 上交作业的同学必做部分（m=5）基本都得分了。泛化的情况属于选做部分，很多同学都给出了思路，主要失分点在于没有考虑到&amp;quot;乐观&amp;quot;这一条件
以下给一个 python 参考代码
def solve(m, n): &amp;#34;&amp;#34;&amp;#34;解决海盗分金问题，时间复杂度 O(m^2lgm)；使用一些技巧可优化到 O(m^2) Args: m (int): 海盗数 n (int): 金币数 Returns: (list): 由第一个人分配，每个人期望分到的金币数，-1 表示无法存活 &amp;#34;&amp;#34;&amp;#34; # 临界情况 if m == 1: return [n] # 递归：规约问题到 m-1 个海盗 plan = solve(m-1, n) # 按照 m-1 个海盗时每个人期望获得的金币数从小到大排序 sorted_plan = sorted(zip(plan, list(range(m-1)))) current_plan = [0] * m remain_money = n # 第一个海盗需要在剩下 m 个海盗中争取到 m/2（下取整）个同意票 for i in range(m//2): expected_money, member_id = sorted_plan[i] expected_money += 1 # 嗜血：需要多给一个金币赢取同意 remain_money -= expected_money # 如果金币不够分了，则无法存活 if remain_money &amp;lt; 0: return plan + [-1] else: current_plan[member_id] = expected_money # 第一个海盗可以获得剩余所有金币 # 注意：到目前为止，去除 -1，current_plan 之和为 n # 此时得到的是一个可行的分配方案 current_plan[-1] = remain_money # 乐观：对于最后需要赢得同意的海盗，可能只需在多人中选部分即可 # 但所有持相同期望金币的都认为自己会被选到，在此要更新他们认为的期望金币 # n &amp;gt;= 6 时乐观起作用 while i+1 &amp;lt; m and sorted_plan[i][0] == sorted_plan[i+1][0]: i += 1 expected_money, member_id = sorted_plan[i] current_plan[member_id] = expected_money + 1 return current_plan 扔鸡蛋 必做题 为了计算 $f(k,m)$，假设在第 $i$ 层楼扔一个蛋。如果碎了，我们还剩 $k-1$ 个蛋，强度肯定小于 $i$，故问题化为 $f(k-1, i)$；如果没碎，把第 $i$ 层楼看做是新的一楼，则问题化为 $f(k, m-i)$。最坏情况是两者的最大值，为了取得最优，我们选择最佳的第 $i$ 层。</description>
    </item>
    
  </channel>
</rss>
